<!DOCTYPE HTML>
<HTML lang="en">
	<Head>
	<Title>Coin Collector</TITLE>
		<script id="2dVertexShader" type="notjs">
			attribute vec4 a_position;	

			attribute vec3 vert_color;

			varying vec3 fragColor;
			
			uniform vec3 transform;
			uniform vec3 rotation;
			uniform vec3 velocity;
			uniform float time;
			
			vec4 PositionObject(vec4 pos) {
			
			vec3 dynamicPosition = vec3(pos.x + velocity.x * time, 
                                    pos.y + velocity.y * time, 
                                    pos.z + velocity.z * time);
			
				mat4 translateM = mat4(1.0,0.0,0.0,0.0,
							   0.0,1.0,0.0,0.0,
							   0.0,0.0,1.0,0.0,
							   transform.x,transform.y,transform.z,1.0);
				return translateM * vec4(dynamicPosition, 1.0);
			}
			vec4 RotateObject(vec4 pos) {
				vec3 c = cos(rotation);
				vec3 s = sin(rotation);
				fragColor = vert_color;
				
				mat4 rotateX = mat4(1.0,  0.0,  0.0,  0.0,
									0.0,  c.x,  -s.x, 0.0,
									0.0,  s.x,  c.x,  0.0,
									0.0,  0.0,  0.0,  1.0);

				mat4 rotateY = mat4(c.y,  0.0, -s.y,  0.0,
									0.0,  1.0, 0.0,   0.0,
									s.y,  0.0, c.y,   0.0,
									0.0,  0.0, 0.0,   1.0);
									
				mat4 rotateZ = mat4(c.z,  -s.z, 0.0,  0.0,
									s.z,  c.z,  0.0,  0.0,
									0.0,  0.0,  1.0,  0.0,
									0.0,  0.0,  0.0,  1.0);
				return rotateZ * rotateY * rotateX * pos;
			}
			void main()
			{

				gl_Position=PositionObject(RotateObject(a_position));
			}		
		</SCRIPT>
		<script id="webglInterface">
			class WebGL_Interface{
				constructor() {
					this.vertexShaderSource = document.getElementById("2dVertexShader").text;
					this.fragmentShaderSource = document.getElementById("2dFragmentShader").text;
					this.vertexShader = this.createShader(gl.VERTEX_SHADER, this.vertexShaderSource);
					this.fragmenShader = this.createShader(gl.FRAGMENT_SHADER, this.fragmentShaderSource);
					this.program = this.createProgram(this.vertexShader,this.fragmenShader);
					gl.viewport(0,0, gl.canvas.width, gl.canvas.height);
					gl.clearColor(1,1,1,1);
					gl.clear(gl.COLOR_BUFFER_BIT);		
					
					gl.enable(gl.DEPTH_TEST);
					
					gl.useProgram(this.program);
				}
				
				createShader(type,source) {
					var shader = gl.createShader(type);
					gl.shaderSource(shader,source);
					gl.compileShader(shader);
					var success = gl.getShaderParameter(shader,gl.COMPILE_STATUS);
					if(success) {
						return shader;
					}
					console.error(gl.getShaderInfoLog(shader));
					gl.deleteShader(shader);
				}
				
				createProgram(vs,fs) {
					var program = gl.createProgram();
					gl.attachShader(program,vs);
					gl.attachShader(program,fs);
					gl.linkProgram(program);
					var succsess = gl.getProgramParameter(program,gl.LINK_STATUS);
					if(succsess){
						return program;
					}
					console.error(gl.getProgramInfoLog(program));
					gl.deleteProgram(program);	
				}
		
			}
		</SCRIPT>
		<script id="2dFragmentShader" type="notjs">
			precision mediump float;
			varying vec3 fragColor;
			void main() {
				gl_FragColor = vec4(fragColor,1);
			}
		</script>
		<script>
			myWebGL = null;
			
			function loop() {
				if (gameOver) return;
				
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				for (let i = 0; i < m.items.length; i++) {
					m.items[i].update();
				}

				let player = m.items[0];
				for (let i = m.items.length - 1; i >= 1; i--) {
					let item = m.items[i];
					if (item instanceof Coin && isColliding(player, item)) {
						score++;
						updateScore();
						m.items.splice(i, 1);
					}
				}
				
				for (let i = m.items.length - 1; i >= 0; i--) {
					let item1 = m.items[i];
					if (!(item1 instanceof Bullet)) continue;

					for (let j = m.items.length - 1; j >= 0; j--) {
						let item2 = m.items[j];
						if (!(item2 instanceof Enemy)) continue;

						if (isColliding(item1, item2, 0.1)) {
							score += 3;
							updateScore();
							m.items.splice(i, 1);
							m.items.splice(j, 1);
							break;
						}
					}
				}
				
				for (let i = m.items.length - 1; i >= 0; i--) {
					let item1 = m.items[i];
					if (!(item1 instanceof Bullet)) continue;

					for (let j = m.items.length - 1; j >= 0; j--) {
						let item2 = m.items[j];
						if (!(item2 instanceof Wall)) continue;

						if (isColliding(item1, item2, 0.1)) {
							m.items.splice(i, 1);
							break;
						}
					}
				}
				
				for (let i = 1; i < m.items.length; i++) {
					let item = m.items[i];
					if (item instanceof Enemy && isColliding(player, item, 0.25)) {
						endGame();
						return;
					}
				}

				for (let i = 0; i < m.items.length; i++) {
					m.items[i].render(m.myWEBGL.program);
				}

				requestAnimationFrame(loop);
			}

			
			class main {	
				constructor(){
					this.myWEBGL = new WebGL_Interface();
					myWebGL= this.myWEBGL;
					this.items = [];
					this.name = "Player";
					
					let player = new Player();
					player.loc = [0, 0, 0];
					this.items.push(player);
					
					let coin = new Coin();
					coin.loc = [.9, .9, 0];
					this.items.push(coin);
					
					let coin2 = new Coin();
					coin2.loc = [.9, -.9, 0];
					this.items.push(coin2);
					
					let coin3 = new Coin();
					coin3.loc = [-.9, .9, 0];
					this.items.push(coin3);
					
					let coin4 = new Coin();
					coin4.loc = [-.9, -.9, 0];
					this.items.push(coin4);
					
					let enemy = new Enemy();
					enemy.loc = [0.75, -0.75, 0];
					enemy.rot[2] = Math.PI;
					this.items.push(enemy);
					
					let enemy2 = new Enemy();
					enemy2.loc = [-0.75, 0.75, 0];
					enemy2.rot[2] = 0;
					this.items.push(enemy2);
					
					let wall = new Wall();
					wall.loc = [0.5, -0.5, 0];
					this.items.push(wall);
					
					let wall2 = new Wall();
					wall2.loc = [0.5, 0.5, 0];
					this.items.push(wall2);
					
					let wall3 = new Wall();
					wall3.loc = [-0.5, -0.5, 0];
					this.items.push(wall3);
					
					let wall4 = new Wall();
					wall4.loc = [-0.5, 0.5, 0];
					this.items.push(wall4);
				}
				
				static canvasHandle(event) {
					var temp = new Bullet();
					temp.loc = [...m.items[0].loc];

					temp.rot = [...m.items[0].rot];

					let angle = temp.rot[2];
					let speed = 0.01;
					temp.velocity = [
						Math.cos(angle) * speed, 
						-Math.sin(angle) * speed,
						0
					];

					m.items.push(temp);
				}
			}			
		</script>
		<script>
			class Player {
				constructor() {
					this.buffer=gl.createBuffer();
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
					this.vertices =
						[	
						-.1,.1,0,0,0,1,
						0,0,0,0,0,1,
						.1,.1,0,0,1,1,
						
						.1,.1,0,0,1,1,
						0,0,0,0,0,1,
						.1,-.1,0,0,1,1,
						
						.1,-.1,0,0,1,1,
						0,0,0,0,0,1,
						-.1,-.1,0,0,0,1,
						
						-.1,-.1,0,0,0,1,
						0,0,0,0,0,1,
						-.1,.1,0,0,0,1
						];
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
					this.loc = [0.0,0.0,0.0];
					this.rot = [0.0,0.0,0.0];
					this.velocity = [0.0, 0.0, 0.0];
					this.rotationSpeed = 0.1;
					this.movementSpeed = 0.005;
				}
				
				update() {
					let newX = this.loc[0] + this.velocity[0];
					let newY = this.loc[1] + this.velocity[1];

					let tempLoc = [newX, newY, this.loc[2]];
					let tempPlayer = {
						loc: tempLoc
					};

					let willCollide = false;

					for (let i = 0; i < m.items.length; i++) {
						let item = m.items[i];
						if (!(item instanceof Wall)) continue;

						if (isColliding(tempPlayer, item, 0.25)) {
							willCollide = true;
							break;
						}
					}

					if (!willCollide) {
						this.loc[0] = newX;
						this.loc[1] = newY;
					}
				}
			 
				 render(program) {
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);

					var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
					var size = 3;
					var type = gl.FLOAT;
					var normalize = false;
					var stride = 6 * Float32Array.BYTES_PER_ELEMENT;
					var offset = 0;
					gl.enableVertexAttribArray(positionAttributeLocation);
					gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

					var colorAttributeLocation = gl.getAttribLocation(program, "vert_color");
					size = 3;
					type = gl.FLOAT;
					normalize = false;
					stride = 6 * Float32Array.BYTES_PER_ELEMENT;
					offset = 3 * Float32Array.BYTES_PER_ELEMENT;
					gl.enableVertexAttribArray(colorAttributeLocation);
					gl.vertexAttribPointer(colorAttributeLocation, size, type, normalize, stride, offset);

					var tranLoc = gl.getUniformLocation(program, 'transform');
					gl.uniform3fv(tranLoc, new Float32Array(this.loc));

					var thetaLoc = gl.getUniformLocation(program, 'rotation');
					gl.uniform3fv(thetaLoc, new Float32Array(this.rot));

					var velocityLoc = gl.getUniformLocation(program, 'velocity');
					gl.uniform3fv(velocityLoc, new Float32Array(this.velocity));

					var timeLoc = gl.getUniformLocation(program, 'time');
					gl.uniform1f(timeLoc, performance.now() / 1000.0);

					var primitiveType = gl.TRIANGLES;
					offset = 0;
					var count = 12;
					gl.drawArrays(primitiveType, offset, count);
				}

				rotateLeft() {
					this.rot[2] -= this.rotationSpeed;
					if (this.rot[2] < -Math.PI) this.rot[2] += 2 * Math.PI;
				}

				rotateRight() {
					this.rot[2] += this.rotationSpeed;
					if (this.rot[2] > Math.PI) this.rot[2] -= 2 * Math.PI;
				}
				moveForward() {
					let angle = this.rot[2]; 
					this.velocity[0] = Math.cos(angle) * this.movementSpeed;
					this.velocity[1] = -Math.sin(angle) * this.movementSpeed;
				}

				moveBackward() {
					let angle = this.rot[2];
					this.velocity[0] = -Math.cos(angle) * this.movementSpeed;
					this.velocity[1] = Math.sin(angle) * this.movementSpeed;
				}
				stop() {
					this.velocity[0] = 0;
					this.velocity[1] = 0;
				}
			}
			class Enemy {
				constructor() {
					this.buffer=gl.createBuffer();
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
					this.vertices =
						[	
						-.1,.1,0,1,0,0,
						0,0,0,1,0,0,
						.1,.1,0,0,0,0,
						
						.1,.1,0,0,0,0,
						0,0,0,1,0,0,
						.1,-.1,0,0,0,0,
						
						.1,-.1,0,0,0,0,
						0,0,0,1,0,0,
						-.1,-.1,0,1,0,0,
						
						-.1,-.1,0,1,0,0,
						0,0,0,1,0,0,
						-.1,.1,0,1,0,0
						];
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
					this.loc = [0.0,0.0,0.0];
					this.rot = [0.0,0.0,0.0];
					let angle = this.rot[2];
					let speed = 0.003;
					this.velocity = [
						Math.cos(angle) * speed,
						-Math.sin(angle) * speed,
						0
					];
					this.size = 0.1;
				}
				
				update() {
					this.loc[0] += this.velocity[0];
					this.loc[1] += this.velocity[1];

					if (this.loc[0] + this.size > 1) {
						this.loc[0] = 1 - this.size;
						this.bounce();
					}
					if (this.loc[0] - this.size < -1) {
						this.loc[0] = -1 + this.size;
						this.bounce();
					}
					if (this.loc[1] + this.size > 1) {
						this.loc[1] = 1 - this.size;
						this.bounce();
					}
					if (this.loc[1] - this.size < -1) {
						this.loc[1] = -1 + this.size;
						this.bounce();
					}

					for (let i = 0; i < m.items.length; i++) {
						let item = m.items[i];
						if (!(item instanceof Wall)) continue;

						if (isColliding(this, item, 0.2)) {
							this.loc[0] -= this.velocity[0] * 2;
							this.loc[1] -= this.velocity[1] * 2;

							this.bounce();
							break;
						}
					}
				}

				bounce() {
					let speed = Math.sqrt(this.velocity[0] ** 2 + this.velocity[1] ** 2);

					let randomAngle = (Math.random() - 0.5) * Math.PI / 2;
					let currentAngle = Math.atan2(this.velocity[1], this.velocity[0]);
					let newAngle = currentAngle + randomAngle;

					this.velocity[0] = Math.cos(newAngle) * speed;
					this.velocity[1] = Math.sin(newAngle) * speed;
				}
			 
				 render(program) {
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);

					var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
					var size = 3;
					var type = gl.FLOAT;
					var normalize = false;
					var stride = 6 * Float32Array.BYTES_PER_ELEMENT;
					var offset = 0;
					gl.enableVertexAttribArray(positionAttributeLocation);
					gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

					var colorAttributeLocation = gl.getAttribLocation(program, "vert_color");
					size = 3;
					type = gl.FLOAT;
					normalize = false;
					stride = 6 * Float32Array.BYTES_PER_ELEMENT;
					offset = 3 * Float32Array.BYTES_PER_ELEMENT;
					gl.enableVertexAttribArray(colorAttributeLocation);
					gl.vertexAttribPointer(colorAttributeLocation, size, type, normalize, stride, offset);

					var tranLoc = gl.getUniformLocation(program, 'transform');
					gl.uniform3fv(tranLoc, new Float32Array(this.loc));

					var thetaLoc = gl.getUniformLocation(program, 'rotation');
					gl.uniform3fv(thetaLoc, new Float32Array(this.rot));

					var velocityLoc = gl.getUniformLocation(program, 'velocity');
					gl.uniform3fv(velocityLoc, new Float32Array(this.velocity));

					var timeLoc = gl.getUniformLocation(program, 'time');
					gl.uniform1f(timeLoc, performance.now() / 1000.0);

					var primitiveType = gl.TRIANGLES;
					offset = 0;
					var count = 12;
					gl.drawArrays(primitiveType, offset, count);
				}
			}
			class Bullet {
				constructor() {
					this.buffer=gl.createBuffer();
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
					this.vertices =
						[	
						-.02,.01,0,.5,.5,.5,
						.02,.01,0,.5,.5,.5,
						-.02,-.01,0,.5,.5,.5,
						
						-.02,-.01,0,.5,.5,.5,
						.02,.01,0,.5,.5,.5,
						.02,-.01,0,.5,.5,.5
						];
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
					this.loc = [0.0,0.0,0.0];
					this.rot = [0.0,0.0,0.0];
					this.velocity = [0.0, 0.0, 0.0];
					this.movementSpeed = 0.005;
				}
				
				update() {
					this.loc[0] += this.velocity[0];
					this.loc[1] += this.velocity[1];
				}
			 
				 render(program) {
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);

					var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
					var size = 3;
					var type = gl.FLOAT;
					var normalize = false;
					var stride = 6 * Float32Array.BYTES_PER_ELEMENT;
					var offset = 0;
					gl.enableVertexAttribArray(positionAttributeLocation);
					gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

					var colorAttributeLocation = gl.getAttribLocation(program, "vert_color");
					size = 3;
					type = gl.FLOAT;
					normalize = false;
					stride = 6 * Float32Array.BYTES_PER_ELEMENT;
					offset = 3 * Float32Array.BYTES_PER_ELEMENT;
					gl.enableVertexAttribArray(colorAttributeLocation);
					gl.vertexAttribPointer(colorAttributeLocation, size, type, normalize, stride, offset);

					var tranLoc = gl.getUniformLocation(program, 'transform');
					gl.uniform3fv(tranLoc, new Float32Array(this.loc));

					var thetaLoc = gl.getUniformLocation(program, 'rotation');
					gl.uniform3fv(thetaLoc, new Float32Array(this.rot));

					var velocityLoc = gl.getUniformLocation(program, 'velocity');
					gl.uniform3fv(velocityLoc, new Float32Array(this.velocity));

					var timeLoc = gl.getUniformLocation(program, 'time');
					gl.uniform1f(timeLoc, performance.now() / 1000.0);

					var primitiveType = gl.TRIANGLES;
					offset = 0;
					var count = 12;
					gl.drawArrays(primitiveType, offset, count);
				}
			}
			class Coin {
				constructor() {
					this.buffer=gl.createBuffer();
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
					const numSegments = 30;
					const radius = 0.05;
					const centerX = 0.0;
					const centerY = 0.0;
					const centerZ = 0.0;
					const color = [1, 1, 0.0];

					this.vertices = [];

					this.vertices.push(centerX, centerY, centerZ, ...color);

					for (let i = 0; i <= numSegments; i++) {
						let angle = (i / numSegments) * 2 * Math.PI;
						let x = centerX + radius * Math.cos(angle);
						let y = centerY + radius * Math.sin(angle);
						this.vertices.push(x, y, centerZ, ...color);
					}

					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
					this.loc = [0.0,0.0,0.0];
					this.rot = [0.0,0.0,0.0];
					this.velocity = [0.0, 0.0, 0.0];
					this.rotationSpeed = 0.02;
				}
				
				update() {
					 this.rot[1] += this.rotationSpeed;
				}
			 
				 render(program) {
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);

					var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
					var size = 3;
					var type = gl.FLOAT;
					var normalize = false;
					var stride = 6 * Float32Array.BYTES_PER_ELEMENT;
					
					gl.enableVertexAttribArray(positionAttributeLocation);
					gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

					var colorAttributeLocation = gl.getAttribLocation(program, "vert_color");
					size = 3;
					type = gl.FLOAT;
					normalize = false;
					stride = 6 * Float32Array.BYTES_PER_ELEMENT;
					offset = 3 * Float32Array.BYTES_PER_ELEMENT;
					gl.enableVertexAttribArray(colorAttributeLocation);
					gl.vertexAttribPointer(colorAttributeLocation, size, type, normalize, stride, offset);

					var tranLoc = gl.getUniformLocation(program, 'transform');
					gl.uniform3fv(tranLoc, new Float32Array(this.loc));

					var thetaLoc = gl.getUniformLocation(program, 'rotation');
					gl.uniform3fv(thetaLoc, new Float32Array(this.rot));

					var velocityLoc = gl.getUniformLocation(program, 'velocity');
					gl.uniform3fv(velocityLoc, new Float32Array(this.velocity));

					var timeLoc = gl.getUniformLocation(program, 'time');
					gl.uniform1f(timeLoc, performance.now() / 1000.0);

					var primitiveType = gl.TRIANGLE_FAN;
					var offset = 0;
					var count = this.vertices.length / 6;
					gl.drawArrays(primitiveType, offset, count);
				}
			}
			
			class Wall {
				constructor() {
					this.buffer=gl.createBuffer();
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
					this.vertices =
						[	
						.1,.1,0,.2,.2,.2,
						-.1,.1,0,.2,.2,.2,
						-.1,-.1,0,.2,.2,.2,
						
						-.1,-.1,0,.2,.2,.2,
						.1,-.1,0,.2,.2,.2,
						.1,.1,0,.2,.2,.2
						];
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
					this.loc = [0.0,0.0,0.0];
					this.rot = [0.0, 0.0, 0.0];
					this.velocity = [0.0, 0.0, 0.0];
				}
				
				update() {}
			 
				 render(program) {
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);

					var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
					var size = 3;
					var type = gl.FLOAT;
					var normalize = false;
					var stride = 6 * Float32Array.BYTES_PER_ELEMENT;
					var offset = 0;
					gl.enableVertexAttribArray(positionAttributeLocation);
					gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

					var colorAttributeLocation = gl.getAttribLocation(program, "vert_color");
					size = 3;
					type = gl.FLOAT;
					normalize = false;
					stride = 6 * Float32Array.BYTES_PER_ELEMENT;
					offset = 3 * Float32Array.BYTES_PER_ELEMENT;
					gl.enableVertexAttribArray(colorAttributeLocation);
					gl.vertexAttribPointer(colorAttributeLocation, size, type, normalize, stride, offset);

					var tranLoc = gl.getUniformLocation(program, 'transform');
					gl.uniform3fv(tranLoc, new Float32Array(this.loc));

					var thetaLoc = gl.getUniformLocation(program, 'rotation');
					gl.uniform3fv(thetaLoc, new Float32Array(this.rot));

					var velocityLoc = gl.getUniformLocation(program, 'velocity');
					gl.uniform3fv(velocityLoc, new Float32Array(this.velocity));

					var timeLoc = gl.getUniformLocation(program, 'time');
					gl.uniform1f(timeLoc, performance.now() / 1000.0);

					var primitiveType = gl.TRIANGLES;
					offset = 0;
					var count = 12;
					gl.drawArrays(primitiveType, offset, count);
				}
			}
 </script>
	</Head>
	<BODY>
		<div style="font-size: 24px; margin-bottom: 10px;">Score: <span id="score">0</span></div>
		<HEADER>
		
		</HEADER>
		
		<CANVAS id="myCanvas" width="1200" height="1200" style = "border: 1px solid #000;">
			Your browser does not support canvas.
		</CANVAS>

		<SCRIPT>
			var canvas = document.getElementById("myCanvas");
			var gl = canvas.getContext("webgl");
			
			var m = new main();
			requestAnimationFrame(loop);			
			
			document.addEventListener("keydown", function(event) {
				if (event.key === "a" || event.key === "A") {
					m.items[0].rotateLeft();
				}
				if (event.key === "d" || event.key === "D") {
					m.items[0].rotateRight();
				}
				if (event.key === "w" || event.key === "W") {
					m.items[0].moveForward();
				}
				if (event.key === "s" || event.key === "S") {
					m.items[0].moveBackward();
				}	
				if (event.key === " ") {
					main.canvasHandle();
				}
			});
			
			document.addEventListener("keyup", function(event) {
				if (event.key === "w" || event.key === "W" || event.key === "s" || event.key === "S") {
					m.items[0].stop();
				}
			});
			
			let score = 0;
			let gameOver = false;
			
			function updateScore() {
				document.getElementById("score").textContent = score;
			}
			
			function isColliding(obj1, obj2, threshold = 0.1) {
				let dx = obj1.loc[0] - obj2.loc[0];
				let dy = obj1.loc[1] - obj2.loc[1];
				let distance = Math.sqrt(dx * dx + dy * dy);
				return distance < threshold;
			}
			
			function endGame() {
				gameOver = true;
				document.getElementById("gameOverMessage").style.display = "block";
			}
		
		</SCRIPT>

		
		<div id="gameOverMessage" style="display: none; font-size: 32px; color: red; margin-bottom: 10px;">
			Game Over!
		</div>
		
	</BODY>
	
</HTML>