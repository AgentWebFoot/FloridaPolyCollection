<!DOCTYPE HTML>
<HTML lang="en">
	<Head>
	<style>
		body {
			text-align: center;
			background-color: black;
		}
		canvas {
		margin-top: 150px;
	}
	</style>
	<Title>Dark Spooky Forest</TITLE>
		<script id="2dVertexShader" type="notjs">
		attribute vec4 a_position;	
		attribute vec3 vert_color;

		uniform vec3 transform;
		uniform vec3 rotation;		

		uniform vec3 worldLoc;
		uniform vec3 worldRotation;
		uniform float n;
		uniform float f;
		uniform float r;
		uniform float t;

		uniform vec3 u_spotLightPosition;
		uniform vec3 u_spotLightDirection;
		uniform vec3 u_moonDirection;

		varying vec3 fragColor;
		varying vec3 fakenormal;
		varying vec3 v_surfaceToLight;
		varying vec3 v_surfaceToView;
		varying vec3 v_spot_surfaceToLight;
		varying vec3 v_worldPosition;

		vec4 MoveCamera(vec4 pos) {
			vec3 cw = cos(worldRotation);
			vec3 sw = sin(worldRotation);

			mat4 rotateX = mat4(
				1.0, 0.0,    0.0,   0.0,
				0.0, cw.x, -sw.x,   0.0,
				0.0, sw.x,  cw.x,   0.0,
				0.0, 0.0,   0.0,    1.0
			);

			mat4 rotateY = mat4(
				cw.y, 0.0, -sw.y, 0.0,
				0.0,  1.0,  0.0,  0.0,
				sw.y, 0.0,  cw.y, 0.0,
				0.0,  0.0,  0.0,  1.0
			);

			mat4 translateView = mat4(
				1.0, 0.0, 0.0, 0.0,
				0.0, 1.0, 0.0, 0.0,
				0.0, 0.0, 1.0, 0.0,
				-worldLoc.x, -worldLoc.y, worldLoc.z, 1.0
			);

			return rotateX * rotateY * translateView * pos;
		}

		vec4 ApplyProjection(vec4 pos) {
			mat4 ComplexPerspective = mat4(
				n/r, 0.0, 0.0, 0.0,
				0.0, n/t, 0.0, 0.0,
				0.0, 0.0, -(f+n)/(f-n), -1.0,
				0.0, 0.0, -2.0*f*n/(f-n), 0.0
			);
			return ComplexPerspective * pos;
		}

		vec4 PositionObject(vec4 pos) {
			mat4 translateM = mat4(
				1.0, 0.0, 0.0, 0.0,
				0.0, 1.0, 0.0, 0.0,
				0.0, 0.0, 1.0, 0.0,
				transform.x, transform.y, transform.z, 1.0
			);
			return translateM * pos;	
		}

		vec4 RotateObject(vec4 pos) {
			vec3 c = cos(rotation);
			vec3 s = sin(rotation);
			fragColor = vert_color;
			mat4 rotateY = mat4(
				c.y, 0.0, -s.y, 0.0,
				0.0, 1.0,  0.0, 0.0,
				s.y, 0.0,  c.y, 0.0,
				0.0, 0.0,  0.0, 1.0
			);
			return rotateY * pos;
		}

		void main() {
			vec4 worldSpace = PositionObject(RotateObject(a_position));
			v_worldPosition = worldSpace.xyz;

			v_surfaceToLight = -normalize(u_moonDirection);

			v_surfaceToView = worldLoc - worldSpace.xyz;
			v_spot_surfaceToLight = u_spotLightPosition - worldSpace.xyz;

			if (length(a_position) < 5.0) {
				fakenormal = RotateObject(a_position).xyz;
			} else {
				fakenormal = vec3(0.0, 1.0, 0.0);
			}

			vec4 cameraSpace = MoveCamera(worldSpace);
			gl_Position = ApplyProjection(cameraSpace);
		}		
		</SCRIPT>
		<script id="2dFragmentShader" type="notjs">
		precision mediump float;
		#define MAX_LIGHTS 12

		varying vec3 fragColor;
		varying vec3 fakenormal;
		varying vec3 v_surfaceToLight;
		varying vec3 v_surfaceToView;
		varying vec3 v_spot_surfaceToLight;
		varying vec3 v_worldPosition;

		uniform vec3 u_spotLightDirection;
		uniform int u_lightCount;
		uniform vec3 u_lightWorldPositions[MAX_LIGHTS];

		void main() {
			float ambient = 0.3;
			vec3 totalPointLight = vec3(0.0);

			for (int i = 0; i < MAX_LIGHTS; i++) {
				if (i >= u_lightCount) break;

				vec3 toFrag = v_worldPosition - u_lightWorldPositions[i];
				float dist = length(toFrag);
				if (dist > 5.0) continue;

				vec3 lightDir = normalize(-toFrag);
				float attenuation = 1.0 / (dist * dist);
				float d = max(dot(normalize(fakenormal), lightDir), 0.0);
				float p = max(dot(normalize(fakenormal), lightDir) * 2.0, 0.0);

				totalPointLight += (d + p) * attenuation * 1.0;
			}

			float moonIntensity = 0.3;
			vec3 moonColor = vec3(.6, .3, .3);

			float d_light = max(dot(normalize(fakenormal), normalize(v_surfaceToLight)), 0.0);
			float p_light = max(dot(normalize(fakenormal), normalize(v_surfaceToLight)) * 2.0, 0.0);
			
			vec3 moonLight = (d_light + p_light) * moonIntensity * moonColor;

			vec3 lightDir = normalize(v_spot_surfaceToLight);
			vec3 spotDir = normalize(u_spotLightDirection);
			float cutoff = cos(10.0 * 3.14159 / 180.0);
			float spotEffect = dot(-lightDir, spotDir);
			float spot_light_power = 0.0;

			if (spotEffect > cutoff) {
				float intensity = max(dot(normalize(fakenormal), lightDir), 0.0);
				float smooth = (spotEffect - cutoff) / (1.0 - cutoff);
				spot_light_power = intensity * smooth * 1.2;
			}

			vec3 finalColor = fragColor * (ambient + totalPointLight + spot_light_power) + moonLight;
			gl_FragColor = vec4(finalColor, 1.0);
		}
		</script>
		
		<script id="webgl_interface">
		class WebGL_Interface {
			constructor() {
				this.vertexShaderSource = document.getElementById("2dVertexShader").text;
				this.fragmentShaderSource = document.getElementById("2dFragmentShader").text;
				this.vertexShader = this.createShader(gl.VERTEX_SHADER, this.vertexShaderSource);
				this.fragmenShader = this.createShader(gl.FRAGMENT_SHADER, this.fragmentShaderSource);
				this.program = this.createProgram(this.vertexShader,this.fragmenShader);
				gl.viewport(0,0, gl.canvas.width, gl.canvas.height);
				gl.clearColor(0,0,0,1);
				gl.clear(gl.COLOR_BUFFER_BIT);		
				gl.enable(gl.DEPTH_TEST);
				
				gl.useProgram(this.program);
				
				var camLoc  = gl.getUniformLocation(this.program,'worldLoc');
				gl.uniform3fv(camLoc,new Float32Array([0,0,0]));
				var worldLoc = gl.getUniformLocation(this.program,'worldRotation');
				gl.uniform3fv(worldLoc,new Float32Array([0,0,0]));
				
				var tempLoc = gl.getUniformLocation(this.program,'n');
				gl.uniform1f(tempLoc,.1);
				tempLoc = gl.getUniformLocation(this.program,'f');
				gl.uniform1f(tempLoc,500);
				tempLoc = gl.getUniformLocation(this.program,'r');
				gl.uniform1f(tempLoc,.1);
				tempLoc = gl.getUniformLocation(this.program,'t');
				gl.uniform1f(tempLoc,.06);
			}
			
			createShader(type,source) {
				var shader = gl.createShader(type);
				gl.shaderSource(shader,source);
				gl.compileShader(shader);
				var success = gl.getShaderParameter(shader,gl.COMPILE_STATUS);
				if(success) {
					return shader;
				}
				console.error(gl.getShaderInfoLog(shader));
				gl.deleteShader(shader);
			}
			
			createProgram(vs,fs) {
				var program = gl.createProgram();
				gl.attachShader(program,vs);
				gl.attachShader(program,fs);
				gl.linkProgram(program);
				var succsess = gl.getProgramParameter(program,gl.LINK_STATUS);
				if(succsess)
				{
					return program;
				}
				console.error(gl.getProgramInfoLog(program));
				gl.deleteProgram(program);	
			}
		
		}
		</script>		
		<script id="BasicGameObject">
		class Transform {
			constructor() {
				this.forward = [0,0,1];
				this.right = [1,0,0];
				this.up = [0,1,0];
			}
		
			doRotations(RotAngles) {
				this.xRot = [
							[1,0,0,0],
							[0,Math.cos(RotAngles[0]),-1*Math.sin(RotAngles[0]),0],
							[0,Math.sin(RotAngles[0]),Math.cos(RotAngles[0]),0],
							[0,0,0,1]
						];		
				this.yRot = [
						[Math.cos(RotAngles[1]),0,Math.sin(RotAngles[1]),0],
						[0,1,0,0],
						[-1*Math.sin(RotAngles[1]),0,Math.cos(RotAngles[1]),0],
						[0,0,0,1]	
						];
				this.zRot = [
							[Math.cos(RotAngles[2]),-1*Math.sin(RotAngles[2]),0,0],
							[Math.sin(RotAngles[2]),Math.cos(RotAngles[2]),0,0],
							[0,0,1,0],
							[0,0,0,1]
						]	
				this.forward = this.crossMultiply(this.zRot,this.crossMultiply(this.yRot,this.crossMultiply(this.xRot,[0,0,1,0])))
				this.right = this.crossMultiply(this.zRot,this.crossMultiply(this.yRot,this.crossMultiply(this.xRot,[1,0,0,0])))
				this.up = this.crossMultiply(this.zRot,this.crossMultiply(this.yRot,this.crossMultiply(this.xRot,[0,1,0,0])))
			}			
			crossMultiply(M,V) {
				console.log(M[0][3]);
				console.log(V[3]);
				var temp = [
							M[0][0]*V[0]+M[0][1]*V[1]+M[0][2] * V[2]+ M[0][3]*V[3],
							M[1][0]*V[0]+M[1][1]*V[1]+M[1][2] * V[2]+ M[1][3]*V[3],
							M[2][0]*V[0]+M[2][1]*V[1]+M[2][2] * V[2]+ M[2][3]*V[3],
							M[3][0]*V[0]+M[3][1]*V[1]+M[3][2] * V[2]+ M[3][3]*V[3]
							]
				console.log(temp);
					return temp;
			}
		}

		class GameObject {
			constructor() {
				this.loc = [0,0,0];
				this.rot = [0,0,0];
				this.isTrigger = false;
				this.collissionRadius = 1.0;
				this.velocity = [0,0,0];
				this.angVelocity = [0,0,0];
				this.name = "default";
				this.id = 0;
				this.prefab;
				this.transform = new Transform();
			}
			
			Move() {
				var tempP = [0,0,0]
				for(var i =0; i< 3;i ++) {
					tempP[i] = this.loc[i];
					tempP[i] += this.velocity[i];
					this.rot[i] += this.angVelocity[i];
				}
				if(!this.isTrigger) {
					var clear = true;
					for(var so in m.Solid) {
						if(m.Solid[so] != this) {
							if(m.CheckCollision(tempP,this.collissionRadius,m.Solid[so].loc,m.Solid[so].collissionRadius)) {
								clear = false;
							}
						}
					} 
					if(clear) {
					this.loc = tempP;
					}
				}
				else {
					this.loc = tempP;
				}
			}

			
			Update() {
				console.error(this.name +" update() is NOT IMPLEMENTED!");
			}
			Render(program) {
				console.error(this.name + " render() is NOT IMPLEMENTED!");
			}	
		}
		
		
		class Ground extends GameObject {
			constructor() {
				super();
				this.buffer=gl.createBuffer();
				this.colorBuffer = gl.createBuffer();
				
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				this.vertices =
				[
					-1000,0,-1000,0,1,0,
					1000,0, -1000,0,1,0,
					-1000,0,1000,0,1,0,
					1000, 0,1000,0,1,0
					
				];
			
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
				this.loc=[0,0,0];
				this.rot=[0,0,0];
			}
			Update() {
			}
			Render(program) {
				var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				var size = 3;
				var type = gl.FLOAT;
				var normalize = false;
				var stride = 6*Float32Array.BYTES_PER_ELEMENT;
				var offset = 0;
				gl.enableVertexAttribArray(positionAttributeLocation);
				gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);
				
				var colorAttributeLocation = gl.getAttribLocation(program,"vert_color");
				size = 3;
				type = gl.FLOAT;
				normalize = false;
				stride = 6*Float32Array.BYTES_PER_ELEMENT;
				offset = 3*Float32Array.BYTES_PER_ELEMENT;
				gl.enableVertexAttribArray(colorAttributeLocation);
				gl.vertexAttribPointer(colorAttributeLocation, size, type, normalize, stride, offset);
						
				var tranLoc  = gl.getUniformLocation(program,'transform');
				gl.uniform3fv(tranLoc,new Float32Array(this.loc));
				var thetaLoc = gl.getUniformLocation(program,'rotation');
				gl.uniform3fv(thetaLoc,new Float32Array(this.rot));
			 
			 gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
			}
		}
		class Camera extends GameObject {
			constructor() {
				super();
				this.movementspeed = .05;
				this.collissionRadius = 0.5;
			}
			Update() {
				var deltaX = 0;
				var deltaZ = 0;
				var deltaR = 0;
				if( "A" in m.Keys && m.Keys["A"]) {
					this.rot[1] -=.01;
				}
				if("D" in m.Keys && m.Keys["D"]) {
					this.rot[1] +=.01;
				}
				if("W" in m.Keys && m.Keys["W"]) {
					this.transform.doRotations(this.rot);
					deltaX += this.transform.forward[0]*this.movementspeed;
					deltaZ += this.transform.forward[2]*this.movementspeed;
				}
				if("S" in m.Keys && m.Keys["S"]) {
					this.transform.doRotations(this.rot);
					deltaX -= this.transform.forward[0]*this.movementspeed;
					deltaZ -= this.transform.forward[2]*this.movementspeed;
				}
				if ("Q" in m.Keys && m.Keys["Q"]) {
					this.rot[0] += .01;
				}
				if ("E" in m.Keys && m.Keys["E"]) {
					this.rot[0] -= .01;
				}
				if ("Z" in m.Keys && m.Keys["Z"]) {
					this.transform.doRotations(this.rot);
					deltaX -= this.transform.right[0]*this.movementspeed;
					deltaZ -= this.transform.right[2]*this.movementspeed;
				}
				if ("C" in m.Keys && m.Keys["C"]) {
					this.transform.doRotations(this.rot);
					deltaX += this.transform.right[0]*this.movementspeed;
					deltaZ += this.transform.right[2]*this.movementspeed;
				}
				
				this.transform.doRotations(this.rot);
				const tempP = [
					this.loc[0] + deltaX,
					this.loc[1],
					-(this.loc[2] + deltaZ)
				];

				let clear = true;
				for (let id in m.Solid) {
					const other = m.Solid[id];
					if (other !== this) {
						if (m.CheckCollision(tempP, this.collissionRadius, other.loc, other.collissionRadius)) {
							clear = false;
							break;
						}
					}
				}

				if (clear) {
					this.loc[0] += deltaX;
					this.loc[2] += deltaZ;
				}
				
				this.rot[0] = Math.max(Math.min(this.rot[0], Math.PI / 2), -Math.PI / 2);
			}
			Render(program) {
						var camLoc  = gl.getUniformLocation(program,'worldLoc');
						gl.uniform3fv(camLoc,new Float32Array(this.loc));
						var worldLoc = gl.getUniformLocation(program,'worldRotation');
						gl.uniform3fv(worldLoc,new Float32Array(this.rot));
			}
			
			
		}
		class Moon extends GameObject {
			constructor() {
				super();
				this.name = "moon";
				this.color = [1.0, 0.0, 0.0];
				this.loc = [20.0, 5.0, 20.0];
				this.rot = [0, 0, 0];

				this.buffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);

				this.vertices = this.generateSphereVertices(1, 16, 16);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
				this.vertexCount = this.vertices.length / 6;
			}

			generateSphereVertices(radius, latBands, longBands) {
				let vertices = [];
				for (let lat = 0; lat <= latBands; lat++) {
					let theta = lat * Math.PI / latBands;
					let sinTheta = Math.sin(theta);
					let cosTheta = Math.cos(theta);

					for (let lon = 0; lon <= longBands; lon++) {
						let phi = lon * 2 * Math.PI / longBands;
						let sinPhi = Math.sin(phi);
						let cosPhi = Math.cos(phi);

						let x = cosPhi * sinTheta;
						let y = cosTheta;
						let z = sinPhi * sinTheta;

						let r = 1.0;
						let g = 1.0;
						let b = 0.9;

						vertices.push(radius * x, radius * y, radius * z, r, g, b);
					}
				}

				let indexData = [];
				for (let lat = 0; lat < latBands; lat++) {
					for (let lon = 0; lon < longBands; lon++) {
						let first = (lat * (longBands + 1)) + lon;
						let second = first + longBands + 1;

						vertices.push(...vertices.slice(first * 6, first * 6 + 6));
						vertices.push(...vertices.slice(second * 6, second * 6 + 6));
						vertices.push(...vertices.slice(first * 6 + 6, first * 6 + 12));

						vertices.push(...vertices.slice(second * 6, second * 6 + 6));
						vertices.push(...vertices.slice(second * 6 + 6, second * 6 + 12));
						vertices.push(...vertices.slice(first * 6 + 6, first * 6 + 12));
					}
				}
				return vertices;
			}

			Update() {
				this.Move();
			}

			Render(program) {
				const tranLoc = gl.getUniformLocation(program, 'transform');
				gl.uniform3fv(tranLoc, new Float32Array(this.loc));

				const rotLoc = gl.getUniformLocation(program, 'rotation');
				gl.uniform3fv(rotLoc, new Float32Array(this.rot));

				const target = [0, 0.0,  40.0]
				const moonDir = [
					target[0] - this.loc[0],
					target[1] - this.loc[1],
					target[2] - this.loc[2]
				];

				const length = Math.hypot(moonDir[0], moonDir[1], moonDir[2]);
				const normalizedDir = [
					moonDir[0] / length,
					moonDir[1] / length,
					moonDir[2] / length
				];

				const moonDirLoc = gl.getUniformLocation(program, 'u_moonDirection');
				gl.uniform3fv(moonDirLoc, new Float32Array(normalizedDir));

				const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				gl.enableVertexAttribArray(positionAttributeLocation);
				gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 0);

				const colorAttributeLocation = gl.getAttribLocation(program, "vert_color");
				gl.enableVertexAttribArray(colorAttributeLocation);
				gl.vertexAttribPointer(colorAttributeLocation, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);

				gl.drawArrays(gl.TRIANGLES, 0, this.vertexCount);
			}
		}
		
		class UFO extends GameObject {
			constructor() {
				super();
				this.rot = [0, 0, 0];
				this.loc = [0, 10.0, 0];
				this.color = [0.0, 0.0, 1.0];
				this.baseHeight = this.loc[1];

				this.baseVertices = this.generateDiscVertices(1.0, 24);
				this.baseBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, this.baseBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.baseVertices), gl.STATIC_DRAW);
				this.baseVertexCount = this.baseVertices.length / 6;

				this.halfSphereVertices = this.generateHalfSphereVertices(0.75, 12, 24);
				this.halfSphereBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, this.halfSphereBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.halfSphereVertices), gl.STATIC_DRAW);
				this.halfSphereVertexCount = this.halfSphereVertices.length / 6;
			}

			generateDiscVertices(radius, segments) {
				const verts = [];
				for (let i = 0; i <= segments; i++) {
					const angle = i * 2 * Math.PI / segments;
					const x = Math.cos(angle) * radius;
					const z = Math.sin(angle) * radius;
					verts.push(0, 0, 0, ...this.color);
					verts.push(x, 0, z, ...this.color);
					const nextAngle = (i + 1) * 2 * Math.PI / segments;
					verts.push(Math.cos(nextAngle) * radius, 0, Math.sin(nextAngle) * radius, ...this.color);
				}
				return verts;
			}

			generateHalfSphereVertices(radius, latBands, longBands) {
				let vertices = [];

				for (let lat = 0; lat <= latBands / 2; lat++) {
					let theta = lat * Math.PI / latBands;
					let sinTheta = Math.sin(theta);
					let cosTheta = Math.cos(theta);

					for (let lon = 0; lon <= longBands; lon++) {
						let phi = lon * 2 * Math.PI / longBands;
						let sinPhi = Math.sin(phi);
						let cosPhi = Math.cos(phi);

						let x = cosPhi * sinTheta;
						let y = cosTheta;
						let z = sinPhi * sinTheta;

						vertices.push(radius * x, radius * y, radius * z, ...this.color);
					}
				}

				let finalVerts = [];
				let longCount = longBands + 1;
				for (let lat = 0; lat < latBands / 2; lat++) {
					for (let lon = 0; lon < longBands; lon++) {
						let first = (lat * longCount + lon) * 6;
						let second = ((lat + 1) * longCount + lon) * 6;

						finalVerts.push(...vertices.slice(first, first + 6));
						finalVerts.push(...vertices.slice(second, second + 6));
						finalVerts.push(...vertices.slice(first + 6, first + 12));

						finalVerts.push(...vertices.slice(second, second + 6));
						finalVerts.push(...vertices.slice(second + 6, second + 12));
						finalVerts.push(...vertices.slice(first + 6, first + 12));
					}
				}

				return finalVerts;
			}

			Update() {
				const player =
					Object.values(m.Solid).find(obj => obj instanceof Camera) ||
					Object.values(m.Trigger).find(obj => obj instanceof Camera);

				if (!player) {
					console.log("No player found");
					return;
				}

				this.rot[1] += 0.01;
				this.loc[1] = this.baseHeight + Math.sin(performance.now() * 0.001) * 0.5;

				const dx = player.loc[0] - this.loc[0];
				const dz = -(player.loc[2]) - this.loc[2];
				const distance = Math.hypot(dx, dz);

				const speed = 0.06;
				if (distance > 0.01) {
					this.loc[0] += (dx / distance) * speed;
					this.loc[2] += (dz / distance) * speed;
				}

				const horizontalDistance = Math.hypot(dx, dz);

				if (horizontalDistance < 1.0) {
					if (!m.shouldReload) {
						m.shouldReload = true;
						setTimeout(() => {
							location.reload();
						}, 500);
					}
				}
			}

			Render(program) {
				gl.uniform3fv(gl.getUniformLocation(program, "transform"), new Float32Array(this.loc));
				gl.uniform3fv(gl.getUniformLocation(program, "rotation"), new Float32Array(this.rot));

				const spotLoc = gl.getUniformLocation(program, "u_spotLightPosition");
				const spotDir = gl.getUniformLocation(program, "u_spotLightDirection");
				const down = [0, -1, 0];

				gl.uniform3fv(spotLoc, new Float32Array(this.loc));
				gl.uniform3fv(spotDir, new Float32Array(down));

				this.drawBuffer(this.baseBuffer, this.baseVertexCount, program);

				this.drawBuffer(this.halfSphereBuffer, this.halfSphereVertexCount, program);
			}

			drawBuffer(buffer, count, program) {
				const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
				const colorAttributeLocation = gl.getAttribLocation(program, "vert_color");

				gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
				gl.enableVertexAttribArray(positionAttributeLocation);
				gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 0);

				gl.enableVertexAttribArray(colorAttributeLocation);
				gl.vertexAttribPointer(colorAttributeLocation, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);

				gl.drawArrays(gl.TRIANGLES, 0, count);
			}
		}
		
		class Candle extends GameObject {
			constructor() {
				super();
				this.loc = [2.0, 0.0, -2.0];
				this.rot = [0, 0, 0];
				this.radius = 0.1;
				this.height = 0.3;
				this.color = [0.9, 0.85, 0.8];
				this.segments = 20;
				this.lightOffset = [0.0, 0.4, 0.0];

				this.buffer = gl.createBuffer();
				this.vertices = this.createCylinderVertices(this.radius, this.height, this.segments);
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);

				this.vertexCount = this.vertices.length / 6;
			}

			createCylinderVertices(radius, height, segments) {
				const verts = [];
				const halfHeight = height / 2;
				for (let i = 0; i < segments; i++) {
					let theta = (i / segments) * 2 * Math.PI;
					let nextTheta = ((i + 1) / segments) * 2 * Math.PI;

					let x1 = Math.cos(theta) * radius;
					let z1 = Math.sin(theta) * radius;
					let x2 = Math.cos(nextTheta) * radius;
					let z2 = Math.sin(nextTheta) * radius;

					let c = this.color;

					verts.push(x1, -halfHeight, z1, ...c);
					verts.push(x1, halfHeight, z1, ...c);
					verts.push(x2, -halfHeight, z2, ...c);

					verts.push(x2, -halfHeight, z2, ...c);
					verts.push(x1, halfHeight, z1, ...c);
					verts.push(x2, halfHeight, z2, ...c);
				}
				return verts;
			}

			Update() {
			}

			Render(program) {
				gl.uniform3fv(gl.getUniformLocation(program, "transform"), new Float32Array(this.loc));
				gl.uniform3fv(gl.getUniformLocation(program, "rotation"), new Float32Array(this.rot));

				const posAttr = gl.getAttribLocation(program, "a_position");
				const colAttr = gl.getAttribLocation(program, "vert_color");

				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				gl.enableVertexAttribArray(posAttr);
				gl.vertexAttribPointer(posAttr, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 0);

				gl.enableVertexAttribArray(colAttr);
				gl.vertexAttribPointer(colAttr, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);

				gl.drawArrays(gl.TRIANGLES, 0, this.vertexCount);
			}
		}
		
		class Tree extends GameObject {
			constructor() {
				super();
				this.loc = [0, 0, 0];
				this.rot = [0, 0, 0];

				this.segments = 20;
				this.coneHeight = 2.5;
				this.coneRadius = 1.2;
				this.trunkHeight = 3.0;
				this.trunkRadius = 0.2;
				
				this.collissionRadius = 0.6;
				this.isTrigger = false;

				this.colorLeaves = [0.1, 0.5, 0.1];
				this.colorTrunk = [0.4, 0.2, 0.05];

				this.vertices = [
					...this.createSphereVertices(1.2, 10, 10),
					...this.createCylinderVertices(this.trunkRadius, this.trunkHeight, this.segments)
				];

				this.buffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
				this.vertexCount = this.vertices.length / 6;
			}

			createSphereVertices(radius, latBands, longBands) {
				const verts = [];
				for (let lat = 0; lat <= latBands; lat++) {
					let theta = lat * Math.PI / latBands;
					let sinTheta = Math.sin(theta);
					let cosTheta = Math.cos(theta);

					for (let lon = 0; lon <= longBands; lon++) {
						let phi = lon * 2 * Math.PI / longBands;
						let sinPhi = Math.sin(phi);
						let cosPhi = Math.cos(phi);

						let x = cosPhi * sinTheta;
						let y = cosTheta;
						let z = sinPhi * sinTheta;

						let leafY = y * radius + this.trunkHeight / 2 + radius;

						verts.push(x * radius, leafY, z * radius, ...this.colorLeaves);
					}
				}

				const finalVerts = [];
				const longs = longBands + 1;
				for (let lat = 0; lat < latBands; lat++) {
					for (let lon = 0; lon < longBands; lon++) {
						let first = (lat * longs + lon) * 6;
						let second = ((lat + 1) * longs + lon) * 6;

						finalVerts.push(...verts.slice(first, first + 6));
						finalVerts.push(...verts.slice(second, second + 6));
						finalVerts.push(...verts.slice(first + 6, first + 12));

						finalVerts.push(...verts.slice(second, second + 6));
						finalVerts.push(...verts.slice(second + 6, second + 12));
						finalVerts.push(...verts.slice(first + 6, first + 12));
					}
				}
				return finalVerts;
			}

			createCylinderVertices(radius, height, segments) {
				const verts = [];
				const halfHeight = height / 2;
				const c = this.colorTrunk;

				for (let i = 0; i < segments; i++) {
					let theta = (i / segments) * 2 * Math.PI;
					let nextTheta = ((i + 1) / segments) * 2 * Math.PI;

					let x1 = Math.cos(theta) * radius;
					let z1 = Math.sin(theta) * radius;
					let x2 = Math.cos(nextTheta) * radius;
					let z2 = Math.sin(nextTheta) * radius;

					verts.push(x1, -halfHeight, z1, ...c);
					verts.push(x1, halfHeight, z1, ...c);
					verts.push(x2, -halfHeight, z2, ...c);

					verts.push(x2, -halfHeight, z2, ...c);
					verts.push(x1, halfHeight, z1, ...c);
					verts.push(x2, halfHeight, z2, ...c);
				}
				return verts;
			}

			Update() {
				this.Move();
			}

			Render(program) {
				gl.uniform3fv(gl.getUniformLocation(program, "transform"), new Float32Array(this.loc));
				gl.uniform3fv(gl.getUniformLocation(program, "rotation"), new Float32Array(this.rot));

				const posAttr = gl.getAttribLocation(program, "a_position");
				const colAttr = gl.getAttribLocation(program, "vert_color");

				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				gl.enableVertexAttribArray(posAttr);
				gl.vertexAttribPointer(posAttr, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 0);

				gl.enableVertexAttribArray(colAttr);
				gl.vertexAttribPointer(colAttr, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);

				gl.drawArrays(gl.TRIANGLES, 0, this.vertexCount);
			}
		}
		
		class Rock extends GameObject {
			constructor() {
				super();
				this.loc = [0, 0, 0];
				this.rot = [0, 0, 0];
				this.collissionRadius = 0.7;
				this.isTrigger = false;

				this.height = 1.0;
				this.radius = 0.6;
				this.color = [0.3, 0.3, 0.3];
				this.sides = 8;

				this.vertices = this.createPrism(this.radius, this.height, this.sides);

				this.buffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);

				this.vertexCount = this.vertices.length / 6;
			}

			createPrism(radius, height, sides) {
				const verts = [];
				const halfHeight = height / 2;
				const c = this.color;

				for (let i = 0; i < sides; i++) {
					let theta = (i / sides) * 2 * Math.PI;
					let nextTheta = ((i + 1) / sides) * 2 * Math.PI;

					let x1 = Math.cos(theta) * radius;
					let z1 = Math.sin(theta) * radius;
					let x2 = Math.cos(nextTheta) * radius;
					let z2 = Math.sin(nextTheta) * radius;

					verts.push(x1, -halfHeight, z1, ...c);
					verts.push(x1, halfHeight, z1, ...c);
					verts.push(x2, -halfHeight, z2, ...c);

					verts.push(x2, -halfHeight, z2, ...c);
					verts.push(x1, halfHeight, z1, ...c);
					verts.push(x2, halfHeight, z2, ...c);
				}
				return verts;
			}

			Update() {
				
			}

			Render(program) {
				gl.uniform3fv(gl.getUniformLocation(program, "transform"), new Float32Array(this.loc));
				gl.uniform3fv(gl.getUniformLocation(program, "rotation"), new Float32Array(this.rot));

				const posAttr = gl.getAttribLocation(program, "a_position");
				const colAttr = gl.getAttribLocation(program, "vert_color");

				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				gl.enableVertexAttribArray(posAttr);
				gl.vertexAttribPointer(posAttr, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 0);

				gl.enableVertexAttribArray(colAttr);
				gl.vertexAttribPointer(colAttr, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);

				gl.drawArrays(gl.TRIANGLES, 0, this.vertexCount);
			}
		}
		</script>
		<script>
		class main {	
			constructor() {
			this.Visual = [];
			this.Solid = [];
			this.Trigger = [];
			this.ObjectCounter = 0;			

			this.myWEBGL = new WebGL_Interface();
			this.myTriangle = [];
			this.Keys = [];
			this.shouldReload = false;
			}
			
			UpdateAll() {
				for(var i in this.Visual) {
					this.Visual[i].Update();
				}
				for(var i in this.Solid) {
					this.Solid[i].Update();
				}
				for(var i in this.Trigger) {
					this.Trigger[i].Update();
				}
			
			}
			
			RenderAll() {
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				const flamePositions = [];
				let lightCount = 0;
				for (let id in this.Trigger) {
					const obj = this.Trigger[id];
					if (obj instanceof Candle) {
						const flame = [
							obj.loc[0] + obj.lightOffset[0],
							obj.loc[1] + obj.lightOffset[1],
							obj.loc[2] + obj.lightOffset[2]
						];
						flamePositions.push(...flame);
						lightCount++;
					}
				}

				const program = this.myWEBGL.program;
				const lightArrayLoc = gl.getUniformLocation(program, "u_lightWorldPositions");
				const lightCountLoc = gl.getUniformLocation(program, "u_lightCount");

				gl.uniform3fv(lightArrayLoc, new Float32Array(flamePositions));
				gl.uniform1i(lightCountLoc, lightCount);

				for (let i in this.Visual) {
					this.Visual[i].Render(program);
				}
				for (let i in this.Solid) {
					this.Solid[i].Render(program);
				}
				for (let i in this.Trigger) {
					this.Trigger[i].Render(program);
				}
			}

			CheckCollision(loc1, rad1, loc2, rad2) {
				const dx = loc1[0] - loc2[0];
				const dy = loc1[1] - loc2[1];
				const dz = loc1[2] - loc2[2];
				const distSq = dx * dx + dy * dy + dz * dz;
				const radiusSum = rad1 + rad2;
				return distSq < (radiusSum * radiusSum);
			}
			
			CreateObject(type, prefab, loc, rot) {
			var temp = new prefab;
			var id = "ID"+this.ObjectCounter;
			this.ObjectCounter ++;
			temp.id = id;
			temp.prefab = prefab;
			temp.loc = loc;
			temp.rot = rot;
				switch(type) {
					case 0:
						this.Visual[id] = temp;
					break;
					case 1:
						this.Solid[id] = temp;
					break;
					case 2:
						this.Trigger[id] = temp;
					break;
					default:
					break;
				}		
			return temp;
			}
			
			
			DestroyObject(id) {
				if(id in this.Visual) {
					delete this.Visual[id];
				}
				if(id in this.Solid) {
					delete this.Solid[id];
				}

				if(id in this.Trigger) {
					delete this.Trigger[id];
				}
			}
			
			KeyDown(event) {
				this.Keys[String.fromCharCode(event.keyCode)] = true;
				console.log(String.fromCharCode(event.keyCode) +" should be true - "+this.Keys[String.fromCharCode(event.keyCode)]);
			}
			
			KeyUp(event) {
				this.Keys[String.fromCharCode(event.keyCode)] = false;
				console.log(String.fromCharCode(event.keyCode) +" should be false - "+this.Keys[String.fromCharCode(event.keyCode)]);
			}
			
			MouseClick(event) {
				var rect = canvas.getBoundingClientRect();
				var realX = event.clientX - rect.left;
				var realY = event.clientY - rect.top;
				console.log(realX+","+realY);
				var x = -1 + 2*realX/myCanvas.width;
				var y = -1 + 2*(myCanvas.height - realY)/myCanvas.height;
				console.log("The click occurred on "+x+","+y);
			}

			static keyD(event) {
				m.KeyDown(event);
			}
			static keyU(event) {
				m.KeyUp(event);
			}

			static mouseH(event) {
				m.MouseClick(event);
			}
			
			static MainLoop() {
				m.UpdateAll();
				m.RenderAll();
				requestAnimationFrame(main.MainLoop);
			}

		}

		</script>
	</Head>
	<BODY style="padding: 15px;">
		<HEADER>
		
		</HEADER>
		
		<CANVAS id="myCanvas" width="960" height="600" style = "border: 1px solid #000;">
			Your browser does not support canvas.
		</CANVAS>
		
		<SCRIPT>
			var canvas = document.getElementById("myCanvas");
			var gl = canvas.getContext("webgl");
			var m = new main();
			window.onkeydown = main.keyD;
			window.onkeyup = main.keyU;
			canvas.addEventListener("click",main.mouseH);
			m.CreateObject(1,Camera,[0,0,0],[0,0,0]);
			
			m.CreateObject(2, Moon, [0, 25.0,  -20.0], [0, 0, 0]);
			m.CreateObject(2, Candle, [-1, -.5, -1], [0, 0, 0]);
			m.CreateObject(2, Candle, [1, -.5, -1], [0, 0, 0]);
			m.CreateObject(2, Candle, [-1, -.5, -2], [0, 0, 0]);
			m.CreateObject(2, Candle, [1, -.5, -2], [0, 0, 0]);
			m.CreateObject(2, Candle, [-1, -.5, -3], [0, 0, 0]);
			m.CreateObject(2, Candle, [1, -.5, -3], [0, 0, 0]);
			
			function randomOutsideCenter(min, centerMin, centerMax, max, y) {
				let valueX;
				let valueZ;
				do {
					valueX = Math.random() * (max - min) + min;
					valueZ = Math.random() * (max - min) + min;
				} while (valueX > centerMin && valueX < centerMax && valueZ > centerMin && valueZ < centerMax);
				return [valueX, y, valueZ];
			}
			
			m.CreateObject(2, UFO, randomOutsideCenter(-40, -30, 30, 40, 5), [0, 0, 0]);
			
			for (let i = 0; i < 50; i++) {
				m.CreateObject(1, Rock, randomOutsideCenter(-20, -3, 3, 20, 0), [0, 0, 0]);
			}
			
			for (let i = 0; i < 300; i++) {
				m.CreateObject(1, Tree, randomOutsideCenter(-40, -5, 5, 40, 0), [0, 0, 0]);
			}
			for (let i = 0; i < 5; i++) {
				m.CreateObject(2, Candle, randomOutsideCenter(-40, -10, 10, 40, -.5), [0, 0, 0]);
			}
			m.CreateObject(2,Ground,[0,-.5,0],[0,0,0]);
			
			requestAnimationFrame(main.MainLoop);	
			
		</SCRIPT>
		
		<FOOTER>
		
		</FOOTER>

		
	</BODY>
	
</HTML>