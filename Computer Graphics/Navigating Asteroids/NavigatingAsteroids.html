<!DOCTYPE HTML>
<HTML lang="en">
	<Head>
		<style>
			body {text-align: center;}
		</style>
		<Title>Navigating Asteroids</TITLE>
		<script id="2dVertexShader" type="notjs">
			attribute vec4 a_position;	
			attribute vec3 vert_color;
			varying vec3 fragColor;
					
			uniform vec3 transform;
			uniform vec3 rotation;		
			
			uniform vec3 worldLoc;
			uniform vec3 worldRotation;
			uniform float n;
			uniform float f;
			uniform float r;
			uniform float t;
			
			varying vec3 fakenormal;
			varying vec3 v_surfaceToLight;
			varying vec3 v_surfaceToView;
			varying vec3 v_spot_surfaceToLight;
			
			vec4 MoveCamera(vec4 pos) {
				vec3 cw = cos(worldRotation);
				vec3 sw = sin(worldRotation);
				mat4 translateView = mat4(1.0,0.0,0.0,0.0,
										  0.0,1.0,0.0,0.0,
										  0.0,0.0,1.0,0.0,
										  -1.0*worldLoc.x,-1.0*worldLoc.y,worldLoc.z,1.0
										);
							
				mat4 rotateView = mat4(cw.y,0.0,-1.0*sw.y,0.0,
										0.0,1.0,0.0,0.0,
										sw.y,0.0,cw.y,0.0,
										0.0,0.0,0.0,1.0);
				return rotateView*translateView*pos;
			}
			
			vec4 ApplyProjection(vec4 pos) {
				mat4 SimpleOrtho = mat4  (1,0.0,0.0,0.0,
								 0.0,1,0.0,0.0, 
								 0.0,0.0,1,0.0, 
								 0.0,0.0,0.0,1.0);

				mat4 ComplexPerspective = mat4(
											n/r, 0.0,0.0,0.0,
											0.0, n/t,0.0,0.0,
											0.0,0.0,-1.0*(f+n)/(f-n),-1.0,
											0.0,0.0,-2.0*f*n/(f-n),0.0
											);
				mat4 ComplexOrtho = mat4(	1.0/r,0.0,0.0,0.0,
											0.0,1.0/t,0.0,0.0,
											0.0,0.0,1.0,0.0,
											0.0,0.0,0.0,1.0
										);
										
				mat4 SimplePerspective = 	mat4(
									1.0,0.0,0.0,0.0,
									0.0,1.0,0.0,0.0,
									0.0,0.0,-1.0,-1.0,
									0.0,0.0,-2.0,0.0			
									);
				return ComplexPerspective*pos;
			}
			
			vec4 PositionObject(vec4 pos) {
				mat4 translateM = mat4(1.0,0.0,0.0,0.0,
							   0.0,1.0,0.0,0.0,
							   0.0,0.0,1.0,0.0,
							   transform.x,transform.y,transform.z,1.0);
				return translateM*pos;	
			}
			vec4 RotateObject(vec4 pos) {
				vec3 c = cos(rotation);
				vec3 s = sin(rotation);
				fragColor = vert_color;
				mat4 rotateX = mat4(
					1.0, 0.0,   0.0,    0.0,
					0.0, c.x,  -s.x,    0.0,
					0.0, s.x,   c.x,    0.0,
					0.0, 0.0,   0.0,    1.0
				);
				mat4 rotateY = mat4(
					c.y, 0.0,  -s.y,    0.0,
					0.0, 1.0,   0.0,    0.0,
					s.y, 0.0,   c.y,    0.0,
					0.0, 0.0,   0.0,    1.0
				);
									
				mat4 rotateZ = mat4(
					c.z, -s.z,  0.0,   0.0,
					s.z,  c.z,  0.0,   0.0,
					0.0,  0.0,  1.0,   0.0,
					0.0,  0.0,  0.0,   1.0
				);
				return rotateZ * rotateY * rotateX*pos;
			}
			void main() {	
				if(length(a_position)<5.0) {
					fakenormal = RotateObject(a_position).xyz;
				}
				else {
					fakenormal = vec3(0.0,1.0,0.0);
				}
				vec4 worldSpace = PositionObject(RotateObject(a_position));
				
				v_surfaceToLight = vec3(0.0,0.0,-5.0) - worldSpace.xyz;
				v_surfaceToView = worldLoc - worldSpace.xyz;
				v_spot_surfaceToLight = vec3(5.0,0.0,-2.0);
				fragColor = vert_color;
				vec4 cameraSpace = MoveCamera(worldSpace);
				
				gl_Position=ApplyProjection(cameraSpace);
			}		
		</SCRIPT>
		<script id="2dFragmentShader" type="notjs">
			precision mediump float;
			varying vec3 fragColor;
			varying vec3 fakenormal;
			varying vec3 v_surfaceToLight;
			varying vec3 v_surfaceToView;
			varying vec3 v_spot_surfaceToLight;
			void main() {
				float ambient = .15;
				gl_FragColor = vec4(ambient*fragColor,1);
				
				float d_light = dot(normalize(fakenormal), normalize(vec3(0.0,0.0,5.0)));
				if(d_light < 0.0) {
					d_light = 0.0;
				}
				gl_FragColor = vec4(fragColor*(ambient + d_light),1);
				
				float p_light = dot(normalize(fakenormal), normalize(v_surfaceToLight))*2.0/length(v_surfaceToLight);
				if(p_light < 0.0) {
					p_light = 0.0;
				}
				gl_FragColor = vec4(fragColor*(p_light + d_light + ambient),1);
				
				float spot_light = dot(normalize(v_spot_surfaceToLight), vec3(1,0,0));
				float spot_light_power = 0.0;
				if(spot_light >= 0.98) {
					spot_light_power = dot(normalize(fakenormal), normalize(v_spot_surfaceToLight));
					if(spot_light_power < 0.0)
					{
						spot_light_power = 0.0;
					}
				}
				gl_FragColor = vec4(fragColor*(p_light + d_light + ambient + spot_light_power),1);
			}
			</script>
			
			<script>
			class WebGL_Interface {
				constructor() {
					this.vertexShaderSource = document.getElementById("2dVertexShader").text;
					this.fragmentShaderSource = document.getElementById("2dFragmentShader").text;
					this.vertexShader = this.createShader(gl.VERTEX_SHADER, this.vertexShaderSource);
					this.fragmenShader = this.createShader(gl.FRAGMENT_SHADER, this.fragmentShaderSource);
					this.program = this.createProgram(this.vertexShader,this.fragmenShader);
					gl.viewport(0,0, gl.canvas.width, gl.canvas.height);
					gl.clearColor(0,0,0,1);
					gl.clear(gl.COLOR_BUFFER_BIT);		
					gl.enable(gl.DEPTH_TEST);
					
					gl.useProgram(this.program);
					
					var camLoc  = gl.getUniformLocation(this.program,'worldLoc');
					gl.uniform3fv(camLoc,new Float32Array([0,0,0]));
					var worldLoc = gl.getUniformLocation(this.program,'worldRotation');
					gl.uniform3fv(worldLoc,new Float32Array([0,0,0]));
					
					var tempLoc = gl.getUniformLocation(this.program,'n');
					gl.uniform1f(tempLoc,.1);
					tempLoc = gl.getUniformLocation(this.program,'f');
					gl.uniform1f(tempLoc,500);
					tempLoc = gl.getUniformLocation(this.program,'r');
					gl.uniform1f(tempLoc,.1);
					tempLoc = gl.getUniformLocation(this.program,'t');
					gl.uniform1f(tempLoc,.06);

					
				}
				
				createShader(type,source) {
					var shader = gl.createShader(type);
					gl.shaderSource(shader,source);
					gl.compileShader(shader);
					var success = gl.getShaderParameter(shader,gl.COMPILE_STATUS);
					if(success)
					{
						return shader;
					}
					console.error(gl.getShaderInfoLog(shader));
					gl.deleteShader(shader);
				}
				
				createProgram(vs,fs) {
					var program = gl.createProgram();
					gl.attachShader(program,vs);
					gl.attachShader(program,fs);
					gl.linkProgram(program);
					var succsess = gl.getProgramParameter(program,gl.LINK_STATUS);
					if(succsess)
					{
						return program;
					}
					console.error(gl.getProgramInfoLog(program));
					gl.deleteProgram(program);	
				}
			
			}
		</script>		
		<script>
			class Transform {
				constructor() {
					this.forward = [0,0,1];
					this.right = [1,0,0];
					this.up = [0,1,0];
				}
			
				doRotations(RotAngles) {
					this.xRot = [
								[1,0,0,0],
								[0,Math.cos(RotAngles[0]),-1*Math.sin(RotAngles[0]),0],
								[0,Math.sin(RotAngles[0]),Math.cos(RotAngles[0]),0],
								[0,0,0,1]
							];		
					this.yRot = [
							[Math.cos(RotAngles[1]),0,Math.sin(RotAngles[1]),0],
							[0,1,0,0],
							[-1*Math.sin(RotAngles[1]),0,Math.cos(RotAngles[1]),0],
							[0,0,0,1]	
							];
					this.zRot = [
								[Math.cos(RotAngles[2]),-1*Math.sin(RotAngles[2]),0,0],
								[Math.sin(RotAngles[2]),Math.cos(RotAngles[2]),0,0],
								[0,0,1,0],
								[0,0,0,1]
							]		
					this.forward = this.crossMultiply(this.zRot,this.crossMultiply(this.yRot,this.crossMultiply(this.xRot,[0,0,1,0])))
					this.right = this.crossMultiply(this.zRot,this.crossMultiply(this.yRot,this.crossMultiply(this.xRot,[1,0,0,0])))
					this.up = this.crossMultiply(this.zRot,this.crossMultiply(this.yRot,this.crossMultiply(this.xRot,[0,1,0,0])))
				}			
				crossMultiply(M,V) {
				var temp = [
							M[0][0]*V[0]+M[0][1]*V[1]+M[0][2] * V[2]+ M[0][3]*V[3],
							M[1][0]*V[0]+M[1][1]*V[1]+M[1][2] * V[2]+ M[1][3]*V[3],
							M[2][0]*V[0]+M[2][1]*V[1]+M[2][2] * V[2]+ M[2][3]*V[3],
							M[3][0]*V[0]+M[3][1]*V[1]+M[3][2] * V[2]+ M[3][3]*V[3]
							]
					return temp;
				}
				
			}


			class GameObject {
				constructor() {
					this.loc = [0,0,0];
					this.rot = [0,0,0];
					this.isTrigger = false;
					this.velocity = [0,0,0];
					this.angVelocity = [0,0,0];
					this.movementSpeed = 0.05;
					this.collissionRadius = 0.4;
					this.name = "default";
					this.id = 0;
					this.prefab;
					this.transform = new Transform();
				}
				
				Move() {
					var tempP = [0,0,0];
					for (var i = 0; i < 3; i++) {
						tempP[i] = this.loc[i] + this.velocity[i];
						this.rot[i] += this.angVelocity[i];
					}
					if (!this.isTrigger) {
						let clear = true;
						for (let other of Object.values(m.Solid)) {
							if (other !== this && m.CheckCollision([tempP[0], tempP[1], -tempP[2]], this.collissionRadius, other.loc, other.collissionRadius)) {
								clear = false;
								break;
							}
						}
						if (clear) {
							for (let other of Object.values(m.Trigger)) {
								if (other !== this && m.CheckCollision([tempP[0], tempP[1], -tempP[2]], this.collissionRadius, other.loc, other.collissionRadius)) {
									clear = false;
									break;
								}
							}
						}
						if (clear) {
							this.loc = tempP;
						}
					} else {
						this.loc = tempP;
					}
				}

				
				Update() {
					console.error(this.name +" update() is NOT IMPLEMENTED!");
				}
				Render(program) {
					console.error(this.name + " render() is NOT IMPLEMENTED!");
				}	
			}
			class Camera extends GameObject {
				constructor() {
					super();
					this.collissionRadius = 0.4;
					this.lastBulletTime = 0;
					this.bulletCooldown = 500;
				}
				Update() {
					this.velocity = [0, 0, 0];
					this.transform.doRotations(this.rot);

					if ("A" in m.Keys && m.Keys["A"]) {
						this.rot[1] -= 0.01;
					}
					if ("D" in m.Keys && m.Keys["D"]) {
						this.rot[1] += 0.01;
					}
					if ("W" in m.Keys && m.Keys["W"]) {
						this.velocity[0] += this.transform.forward[0] * this.movementSpeed;
						this.velocity[2] += this.transform.forward[2] * this.movementSpeed;
					}
					if ("S" in m.Keys && m.Keys["S"]) {
						this.velocity[0] -= this.transform.forward[0] * this.movementSpeed;
						this.velocity[2] -= this.transform.forward[2] * this.movementSpeed;
					}
					if ("Z" in m.Keys && m.Keys["Z"]) {
						this.velocity[1] += this.movementSpeed;
					}
					if ("X" in m.Keys && m.Keys["X"]) {
						this.velocity[1] -= this.movementSpeed;
					}

					this.Move();
					
					if ("E" in m.Keys && m.Keys["E"]) {
						let currentTime = Date.now();
						if (currentTime - this.lastBulletTime >= this.bulletCooldown) {
							m.CreateObject(0, Bullet, 
								[this.loc[0], this.loc[1] - 0.1, -this.loc[2]], 
								[this.transform.forward[0], this.transform.forward[1], -this.transform.forward[2]]
							);
							this.lastBulletTime = currentTime;
						}
					}
					
				}
				Render(program) {
							var camLoc  = gl.getUniformLocation(program,'worldLoc');
							gl.uniform3fv(camLoc,new Float32Array(this.loc));
							var worldLoc = gl.getUniformLocation(program,'worldRotation');
							gl.uniform3fv(worldLoc,new Float32Array(this.rot));
				}
				
				
			}

			class Asteroid extends GameObject {
				constructor() {
					super();
					this.isTrigger = true;
					this.buffer=gl.createBuffer();
					 gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
					 
					 this.vertices = [
									0, .25, 0, 1, 0, 0,
									.25, 0, 0, 1, 0, 0,
									0, 0, -.25, 1, 0, 0,

									0, .25, 0, 0, 1, 0,
									.25, 0, 0, 0, 1, 0,
									0, 0, .25, 0, 1, 0,

									0, .25, 0, 0, 0, 1,
									-.25, 0, 0, 0, 0, 1,
									0, 0, -.25, 0, 0, 1,

									0, .25, 0, 0, 1, 1,
									-.25, 0, 0, 0, 1, 1,
									0, 0, .25, 0, 1, 1,

									0, -.25, 0, 1, 1, 0,
									.25, 0, 0, 1, 1, 0,
									0, 0, -.25, 1, 1, 0,

									0, -.25, 0, 1, 0, 1,
									.25, 0, 0, 1, 0, 1,
									0, 0, .25, 1, 0, 1,

									0, -.25, 0, 1, 0, 0,
									-.25, 0, 0, 1, 0, 0,
									0, 0, -.25, 1, 0, 0,

									0, -.25, 0, 0, 0, 1,
									-.25, 0, 0, 0, 0, 1,
									0, 0, .25, 0, 0, 1
								];
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
					this.loc = [0.0,0.0,0.0];
					this.rot = [0.0,0.0,0.0];
					this.angVelocity = [Math.random() * (0.5 - 0.01) + 0.01 , Math.random() * (0.5 - 0.01) + 0.01, Math.random() * (0.5 - 0.01) + 0.01];
					this.collissionRadius = 0.4;
					this.hitCount = 0;
				}
				
				registerHit() {
					this.hitCount++;
					if (this.hitCount >= 3) {
						m.DestroyObject(this.id);
					}
				}
							
				Render(program) {
					var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
					var size = 3;
					var type = gl.FLOAT;
					var normalize = false;
					var stride = 6*Float32Array.BYTES_PER_ELEMENT;
					var offset = 0;
					gl.enableVertexAttribArray(positionAttributeLocation);
					gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);
						
					var colorAttributeLocation = gl.getAttribLocation(program,"vert_color");
					size = 3;
					type = gl.FLOAT;
					normalize = false;
					stride = 6*Float32Array.BYTES_PER_ELEMENT;
					offset = 3*Float32Array.BYTES_PER_ELEMENT;
					gl.enableVertexAttribArray(colorAttributeLocation);
					gl.vertexAttribPointer(colorAttributeLocation, size, type, normalize, stride, offset);
							
					var tranLoc  = gl.getUniformLocation(program,'transform');
					gl.uniform3fv(tranLoc,new Float32Array(this.loc));
					var thetaLoc = gl.getUniformLocation(program,'rotation');
					gl.uniform3fv(thetaLoc,new Float32Array(this.rot));
					
					
					var primitiveType = gl.TRIANGLES;
					offset = 0;
					var count = 24;
					gl.drawArrays(primitiveType, offset, count);
				}
				Update() {
					this.Move();
				}
				
			}
			class Bullet extends GameObject {
				constructor(startLoc, direction) {
					super();
					this.loc = [...startLoc];
					this.direction = [...direction];

					this.velocity = 0.05;
					this.collissionRadius = 0.1;
					this.name = "bullet";
					this.buffer = gl.createBuffer();
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
					this.vertices = [
						-0.05, -0.05, 0,  1, 1, 0,
						 0.05, -0.05, 0,  1, 1, 0,
						 0,     0.05, 0,  1, 1, 0
					];
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
				}

				Update() {
					for (let i = 0; i < 3; i++) {
						this.loc[i] += this.direction[i] * this.velocity;
					}
					
					for (let id in m.Solid) {
						const asteroid = m.Solid[id];
						if (asteroid instanceof Asteroid && m.CheckCollision(this.loc, this.collissionRadius, asteroid.loc, asteroid.collissionRadius)) {
							asteroid.registerHit();
							m.DestroyObject(this.id);
							break;
						}
					}
				}

				Render(program) {
					const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
					gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
					gl.enableVertexAttribArray(positionAttributeLocation);
					gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 24, 0);

					const colorAttributeLocation = gl.getAttribLocation(program, "vert_color");
					gl.enableVertexAttribArray(colorAttributeLocation);
					gl.vertexAttribPointer(colorAttributeLocation, 3, gl.FLOAT, false, 24, 12);

					const tranLoc = gl.getUniformLocation(program, 'transform');
					gl.uniform3fv(tranLoc, new Float32Array(this.loc));
					const thetaLoc = gl.getUniformLocation(program, 'rotation');
					gl.uniform3fv(thetaLoc, new Float32Array(this.rot));

					gl.drawArrays(gl.TRIANGLES, 0, 3);
				}
			}
			
		</script>
		<script>
			class main {	
				constructor() {
				this.Visual = [];
				this.Solid = [];
				this.Trigger = [];
				this.ObjectCounter = 0;			

				this.myWEBGL = new WebGL_Interface();
				this.myTriangle = [];
				this.Keys = [];
				}
				
				UpdateAll() {
					for(var i in this.Visual) {
						this.Visual[i].Update();
					}
					for(var i in this.Solid) {
						this.Solid[i].Update();
					}
					for(var i in this.Trigger) {
						this.Trigger[i].Update();
					}
				
				}
				
				RenderAll() {
					gl.clear(gl.COLOR_BUFFER_BIT);
					for(var i in this.Visual) {
						this.Visual[i].Render(this.myWEBGL.program);
					}
					for(var i in this.Solid) {
						this.Solid[i].Render(this.myWEBGL.program);
					}
					for(var i in this.Trigger) {
						this.Trigger[i].Render(this.myWEBGL.program);
					}
				
				}
				
				CheckCollision(loc1, rad1, loc2, rad2) {
					const dx = loc1[0] - loc2[0];
					const dy = loc1[1] - loc2[1];
					const dz = loc1[2] - loc2[2];
					const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
					return distance < (rad1 + rad2);
				}
				
				CreateObject(type, prefab, loc, rot) {
					var temp = new prefab(loc, rot);
					var id = "ID"+this.ObjectCounter;
					this.ObjectCounter ++;
					temp.id = id;
					temp.prefab = prefab;
					temp.loc = loc;
					temp.rot = rot;
						switch(type) {
							case 0:
								this.Visual[id] = temp;
							break;
							case 1:
								this.Solid[id] = temp;
							break;
							case 2:
								this.Trigger[id] = temp;
							break;
							default:
							break;
						}		
					return temp;
				}
				
				
				DestroyObject(id) {
					if(id in this.Visual) {
						delete this.Visual[id];
					}
					if(id in this.Solid) {
						delete this.Solid[id];
					}

					if(id in this.Trigger) {
						delete this.Trigger[id];
					}
				}
			
				KeyDown(event) {
					this.Keys[String.fromCharCode(event.keyCode)] = true;
				}
				
				KeyUp(event) {
					this.Keys[String.fromCharCode(event.keyCode)] = false;
				}
				
				MouseClick(event) {
					var rect = canvas.getBoundingClientRect();
					var realX = event.clientX - rect.left;
					var realY = event.clientY - rect.top;
					var x = -1 + 2*realX/myCanvas.width;
					var y = -1 + 2*(myCanvas.height - realY)/myCanvas.height;
				}
				
				static keyD(event) {
					m.KeyDown(event);
				}
				static keyU(event) {
					m.KeyUp(event);
				}

				static mouseH(event) {
					m.MouseClick(event);
				}
				
				static MainLoop() {
					m.UpdateAll();
					m.RenderAll();
					requestAnimationFrame(main.MainLoop);
				}

			}
			
			
		</script>
	</Head>
	<BODY style="padding: 15px;">
		<HEADER>
		
		</HEADER>
		
		<CANVAS id="myCanvas" width="800" height="800" style = "border: 1px solid #000;">
			Your browser does not support canvas.
		</CANVAS>
		
		<SCRIPT>
			var canvas = document.getElementById("myCanvas");
			var gl = canvas.getContext("webgl");
			var m = new main();
			window.onkeydown = main.keyD;
			window.onkeyup = main.keyU;
			canvas.addEventListener("click",main.mouseH);
			for(var i =0; i < 200; i++) {
				m.CreateObject(1, Asteroid, [Math.random() * 100 - 50, Math.random() * 20 - 10, Math.random() * 100 - 50],[0,0,0]);
				
			}
			m.CreateObject(0,Camera,[0,0,0],[0,0,0]);
			requestAnimationFrame(main.MainLoop);	
		</SCRIPT>
	</BODY>
</HTML>