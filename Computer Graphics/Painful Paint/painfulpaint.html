<!DOCTYPE HTML>
<HTML lang="en">
	<Head>
	<Title>Painful Paint</Title>
		<script id="2dVertexShader" type="notjs">
		attribute vec4 a_position;	
		
		attribute vec3 a_color;
		
		varying vec3 fragColor;
		void main() {
			fragColor = a_color;
			gl_Position=a_position;
		}		
		</SCRIPT>
		<script id="2dFragmentShader" type="notjs">
		precision mediump float;
		varying vec3 fragColor;
		void main() {
			gl_FragColor = vec4(fragColor,1);
		}
		</script>
		
		<script>
		class WebGL_Interface {
			constructor() {
				
				gl.viewport(0,0, gl.canvas.width, gl.canvas.height);
				
				gl.clearColor(1,1,1,1);
				gl.clear(gl.COLOR_BUFFER_BIT);
				
				var vertexShaderSource = document.getElementById("2dVertexShader").text;
				var fragmentShaderSource = document.getElementById("2dFragmentShader").text;
				var vertexShader = this.createShader(gl.VERTEX_SHADER, vertexShaderSource);
				var fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
				
				this.program = this.createProgram(vertexShader, fragmentShader);
				
				gl.useProgram(this.program);
			}
			createShader(type,source) {
				var shader = gl.createShader(type);
				gl.shaderSource(shader,source);
				gl.compileShader(shader);
				var success = gl.getShaderParameter(shader,gl.COMPILE_STATUS);
				if (success) {
					return shader;
				}
				
				console.error(gl.getShaderInfoLog(shader));
				gl.deleteShader(shader);
			}
			
			createProgram(vs,fs) {
				var program = gl.createProgram();
				gl.attachShader(program, vs);
				gl.attachShader(program, fs);
				gl.linkProgram(program);
				var success = gl.getProgramParameter(program, gl.LINK_STATUS);
				if (success) {
					return program;
				}
				console.error(gl.getProgramInfoLog(program));
				gl.deleteProgram(program);
			}
		}
		</script>
		<script>
		class main {	
			constructor() {
				this.x = 10;
				this.myWEBGL = new WebGL_Interface();
				this.program = this.myWEBGL.program;
				this.myShapes = [];
				this.selectedColor = [1, 0, 0];

				document.getElementById("colorPicker").addEventListener("input", (event) => {
					this.colorHandle(event.target.value);
				});
			}
			
			static checkboxH(event) {
				m.toggleFillMode(event.target.checked);
			}

			colorHandle(hexColor) {
				this.selectedColor = [
					parseInt(hexColor.substring(1, 3), 16) / 255,
					parseInt(hexColor.substring(3, 5), 16) / 255,
					parseInt(hexColor.substring(5, 7), 16) / 255
				];
			}

			canvasHandle(event) {
				var rect = canvas.getBoundingClientRect();
				var realX = event.clientX - rect.left;
				var realY = event.clientY - rect.top;
				var x = -1 + 2 * realX / myCanvas.width;
				var y = -1 + 2 * (myCanvas.height - realY) / myCanvas.height;

				if (this.myShapes.length === 0 || this.myShapes[this.myShapes.length - 1].isFinished) {
					var shapeType = document.getElementById("mySel").value;
					var isFilled = document.getElementById("fillCheckbox").checked;
					var temp = new Shape(shapeType, this.selectedColor, isFilled);
					temp.addPoint(x, y);
					this.myShapes.push(temp);
				} else {
					this.myShapes[this.myShapes.length - 1].addPoint(x, y);
				}
				this.renderAll();
			}
			mouseMove(event) {
				if (this.myShapes.length !== 0 && !this.myShapes[this.myShapes.length-1].isFinished) {
					var rect = canvas.getBoundingClientRect();
					var realX = event.clientX - rect.left;
					var realY = event.clientY - rect.top;
					console.log(realX+","+realY);
					var x = -1 + 2*realX/myCanvas.width;
					var y = -1 + 2*(myCanvas.height - realY)/myCanvas.height;
					this.myShapes[this.myShapes.length-1].tempAdd(x,y);
					this.renderAll();
					this.myShapes[this.myShapes.length-1].tempRemove();
				}
			}
			renderAll() {
				for(let i=0; i < this.myShapes.length; i++) {
					this.myShapes[i].render(this.program);
				}
			}
			menuHandle(menu) {
				console.log("The menu option is "+ menu.selectedIndex);
				console.log("the menu value is "+menu.value);
			}
			
			buttonHandle() {
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
				this.myShapes = [];
				console.log("You clicked the button");
			}
			
			handleRightClick(event) {
				var rect = canvas.getBoundingClientRect();
				var realX = event.clientX - rect.left;
				var realY = event.clientY - rect.top;
				var x = -1 + 2 * realX / myCanvas.width;
				var y = -1 + 2 * (myCanvas.height - realY) / myCanvas.height;

				if (this.myShapes.length !== 0 && !this.myShapes[this.myShapes.length - 1].isFinished) {
					this.myShapes[this.myShapes.length - 1].isFinished = true;
					this.renderAll();
				}
			}
			
			static keyD(event) {
				m.keyDown(event);
			}
			
			static mouseH(event) {
				m.canvasHandle(event);
			}
			
			static mouseM(event) {
				m.mouseMove(event);
			}
			
			static menuH() {
				m.menuHandle(this);
			}
			
			static buttonH() {
				m.buttonHandle();
			}
			
			static rightClickH(event) {
				event.preventDefault();
				m.handleRightClick(event);
			}
		}
		
		class Shape {
			constructor(shapeType, color, filled) {
				this.isFinished = false;
				this.vertCount = 0;
				this.positions = [];
				this.shapeType = shapeType;
				this.color = color;
				this.positionBuffer = gl.createBuffer();
				this.filled = filled;

				gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.positions), gl.STATIC_DRAW);
			}
			
			generateBox(x1, y1, x2, y2) {
				return [
					x1, y1, 0, ...this.color,
					x2, y1, 0, ...this.color,
					x2, y2, 0, ...this.color,
					x1, y2, 0, ...this.color
				];
			}

			addPoint(x, y) {
				if (this.shapeType === "Circle") {
					if (this.vertCount === 0) {
						this.positions.push(x, y, 0, ...this.color);
						this.center = { x: x, y: y };
						this.vertCount++;
					} 
					else if (this.vertCount === 1) {
						let radius = Math.sqrt(
							Math.pow(x - this.center.x, 2) + Math.pow(y - this.center.y, 2)
						);

						for (let i = 0; i <= 36; i++) {
							let angle = (i / 36) * 2 * Math.PI;
							let px = this.center.x + radius * Math.cos(angle);
							let py = this.center.y + radius * Math.sin(angle);
							this.positions.push(px, py, 0, ...this.color);
						}

						gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
						gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.positions), gl.STATIC_DRAW);

						this.vertCount = 37;
						this.isFinished = true;
					}
				}
				else if (this.shapeType === "Box") {
					if (this.vertCount === 0) {
						this.positions.push(x, y, 0, ...this.color);
						this.vertCount++;
					} 
					else if (this.vertCount === 1) {
						
						const x1 = this.positions[0];
						const y1 = this.positions[1];
						
						
						this.positions = this.generateBox(x1, y1, x, y);
						this.vertCount = 4;
						this.isFinished = true;

						
						gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
						gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.positions), gl.STATIC_DRAW);
					}
				}

				else {
					this.positions.push(x, y, 0, ...this.color);
					gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.positions), gl.STATIC_DRAW);
					this.vertCount++;
				}

				if (this.shapeType === "Triangle" && this.vertCount === 3) {
					this.isFinished = true;
				}
				else if (this.shapeType === "Line" && this.vertCount === 2) {
					this.isFinished = true;
				}
			}
			
			tempAdd(x, y) {
				if (this.shapeType === "Circle" && this.vertCount === 1) {
					let radius = Math.sqrt(
						Math.pow(x - this.center.x, 2) + Math.pow(y - this.center.y, 2)
					);

					let tempCircle = [];
					
					for (let i = 0; i <= 36; i++) {
						let angle = (i / 36) * 2 * Math.PI;
						let px = this.center.x + radius * Math.cos(angle);
						let py = this.center.y + radius * Math.sin(angle);
						tempCircle.push(px, py, 0, ...this.color);
					}

					gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tempCircle), gl.STATIC_DRAW);
					this.vertCount = 37;
				}
				
				else if (this.shapeType === "Box" && this.vertCount === 1) {
					const x1 = this.positions[0];
					const y1 = this.positions[1];

					let tempBox = this.generateBox(x1, y1, x, y);

					gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tempBox), gl.STATIC_DRAW);

					this.vertCount = 4;
				}
				
				else {
					this.positions.push(x, y, 0, ...this.color);
					gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.positions), gl.STATIC_DRAW);
					this.vertCount++;
				}
			}

			tempRemove() {
				if (this.shapeType === "Circle" && this.vertCount > 1) {
					this.vertCount = 1;
					this.positions = this.positions.slice(0, 6);

					gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.positions), gl.STATIC_DRAW);
				}
				
				else if (this.shapeType === "Box" && this.vertCount === 4) {
					this.vertCount = 1;

					this.positions = this.positions.slice(0, 6);

					gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.positions), gl.STATIC_DRAW);
				}
				
				else {
					if (this.vertCount > 0) {
						this.positions.splice(-6);
						gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
						gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.positions), gl.STATIC_DRAW);
						this.vertCount--;
					}
				}
			}

			toggleFill() {
				this.filled = !this.filled;
			}

			render(program) {
				gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
				var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
				gl.enableVertexAttribArray(positionAttributeLocation);

				var size = 3;
				var type = gl.FLOAT;
				var normalize = false;
				var stride = 6 * Float32Array.BYTES_PER_ELEMENT;
				var offset = 0;
				gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

				var colorAttributeLocation = gl.getAttribLocation(program, "a_color");
				gl.enableVertexAttribArray(colorAttributeLocation);
				gl.vertexAttribPointer(colorAttributeLocation, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);

				if (!this.isFinished) {
					gl.drawArrays(gl.LINE_LOOP, 0, this.vertCount);
				} else {
					if (this.shapeType == "Triangle") {
						var primitiveType = this.filled ? gl.TRIANGLES : gl.LINE_LOOP;
						gl.drawArrays(primitiveType, 0, this.vertCount);
					}
					else if (this.shapeType == "Box") {
						var primitiveType = this.filled ? gl.TRIANGLE_FAN: gl.LINE_LOOP;
						gl.drawArrays(primitiveType, 0, this.vertCount);
					}
					else if (this.shapeType == "Line") {
						gl.drawArrays(gl.LINE_LOOP, 0, this.vertCount);
					}
					else if (this.shapeType == "Polygon") {
						var primitiveType = this.filled ? gl.TRIANGLE_FAN: gl.LINE_LOOP;
						gl.drawArrays(primitiveType, 0, this.vertCount);
					}
					else if (this.shapeType == "Circle") {
						var primitiveType = this.filled ? gl.TRIANGLE_FAN : gl.LINE_LOOP;
						gl.drawArrays(primitiveType, 1, this.vertCount - 1);
					}
				}
			}
		}
	</script>

	</Head>
	<BODY style="padding: 15px;">
		<HEADER>
		
		</HEADER>
		
		<CANVAS id="myCanvas" width="640" height="640" style = "border: 1px solid #000;">
			Your browser does not support canvas.
		</CANVAS>
		
		<button id="myB">Clear Canvas</button>
		
		
		<select id="mySel" size = "5">
			<option value="Box">Box</option>
			<option value="Line">Line</option>
			<option value="Circle">Circle</option>
			<option value="Triangle" selected>Triangle</option>
			<option value="Polygon">N Polygon</option>
		</select>
		
		<input type="color" id="colorPicker" value="#ff0000">
		
		<label>
			<input type="checkbox" id="fillCheckbox" checked> Filled
		</label>
		
		<SCRIPT>
			var canvas = document.getElementById("myCanvas");
			var gl = canvas.getContext("webgl");
			
			var m = new main();
			
			window.onkeydown = main.keyD;
			canvas.addEventListener("click",main.mouseH);
			canvas.addEventListener("mousemove",main.mouseM);
			canvas.addEventListener("contextmenu", main.rightClickH);
			var mySel = document.getElementById("mySel");
			mySel.addEventListener("click", main.menuH);
			var myB = document.getElementById("myB");
			myB.addEventListener("click",main.buttonH);
			
		</SCRIPT>
	</BODY>
</HTML>